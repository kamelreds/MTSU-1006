PROGRAM_NAME='MTSU Science 1006 Rack NI3100'
(***********************************************************)
(***********************************************************)
(*  FILE_LAST_MODIFIED_ON: 10/03/2017  AT: 10:01:10        *)
(***********************************************************)
(* System Type : NetLinx                                   *)
(***********************************************************)
(* REV HISTORY:                                            *)
(***********************************************************)
(*	       MMMMMMMMMMMMMMMMMMMMMMMMMMMM
          MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  
       MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMM         NMMMMMM   MMMMM         OMMMMMMMMMMMMM 
MMMMMMMMMMMM  MMMM7   $MMMMM   MMMMM   MMMM    MMMMMMMMMMMM 
MMMMMMMMMMMM  MMMMMM   MMMMM   MMMMM   MMMMMM   MMMMMMMMMMM 
MMMMMMMMMMMM  MMMMMM   MMMMM   MMMMM   MMMMMM   MMMMMMMMMMM 
MMMMMMMMMMMM  MMMMM:  ?MMMMM   MMMMM   MMMMMM   MMMMMMMMMMM 
MMMMMMMMMMMM         MMMMMMM   MMMMM   MMMM    MMMMMMMMMMMM 
MMMMMMMMMMMM  MM$    MMMMMMM   MMMMM         NMMMMMMMMMMMMM 
MMMMMMMMMMMM  MMMMM   MMMMMM   MMMMM   MMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMM  MMMMM8  8MMMMM   MMMMM   MMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMM  MMMMMM   MMMMM   MMMMM   MMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMM  MMMMMMM   MMMM   MMMMM   MMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMM  MMMMMMM,  MMMM   MMMMM   MMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMMMMMMM     MMMMMMM     MMMMMMMM           MMMMMM      MM 
MMMMMMM8       MMMMMM      MMMMN      OM,      MM      MMMM 
MMMMMM$         MMMMM        M        MMMM           DMMMMM 
MMMMM7    D     MMMM             IMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMM,    MMM     MMM?MMMMMMMMMMMMMMMMMMMMMM,       MMMMMMMM 
MMM          MNMMMMMM,  ,MMMMMMMO    MMMM~          MMMMMMM 
MM     7MMMMM     MZ    MMMMMMMM     MM?      M~      MMMMM 
M  MMMMMMMMMMO          MMMMMMMM     M      MMMMN      MMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM 
		AMX LLC.  1982-2014
    Killed by tragic Harmin International buyout
*)
(***********************************************************)
(*          DEVICE NUMBER DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_DEVICE

//SYSTEM DEVICES START HERE
dvMASTER	=	0:1:0					//THAT IS THIS MASTER RIGHT HERE
dvDVX_MASTER	=	0:1:10063					//MASTER INSIDE THE PODIUM DVX
dvDGX_MASTER	=	0:1:10062					//MASTER INSIDE THE RACK DGX

dvDGX_SWITCHER	=	5002:2:10062				//SWITCHING PORT OF THE DGX

dvTP		=	10001:1:0				//MXT1001 TOUCH PANEL
dvVTC_TP	=	10001:3:0				//TP PORT FOR VTC SNAPI
dvRMS_TP	=	10001:7:0				//TP PORT 7 FOR THE RMS PAGES

vdvRMS		=	41001:1:0				//VDV FOR THE RMS CLIENT GATEWAY
vdvRMS_GUI	=	41002:1:0				//VDV FOR THE RMG GUI MODULE

vdvRMSSourceUsage = 	33001:1:0				//VDV FOR RMS SOURCE USEAGE MONITOR

//PHYSICAL DEVICES START HERE

//DEVICES LOCALLY ATTACHED TO THE NI-3100
dvCAM_SWITCH	=	5001:1:0				//BLACKMAGIC SMART VIDEOHUB ON COM 1
vdvCAM_SWITCH	=	33010:1:0				//VDV FOR THE CAM SWITCHER

dvDGX_RS232	=	5001:2:0				//RS232 FOR THE DGX SWITCHER

dvDSP		=	5001:3:0				//RS232 FOR THE DSP WHICH IS A BIAMP TESIRA SERVER-IO WHICH IS ALSO RATHER AWESOME!!!
vdvDSP		=	33011:1:0				//VDV FOR THE DSP MONITOR
vdvDSP_PGM	=	33011:2:0				//PGM VOLUME/MUTE CONTROL VDV
vdvDSP_SP	=	33011:3:0				//SPEECH VOLUME/MUTE CONTROL VDV

dvLIGHTING	=	5001:5:0				//ETC LIGHTING SYSTEM
vdvLIGHTING	=	33013:1:0				//VDV FOR THE LIGHTING SYSTEM

dvUPS		=	5001:6:0				//MIDDLE ATLANTIC UPS
vdvUPS		=	33014:1:0				//VDV FOR THE UPS


//DEVICES ATTACHED TO THE DVX3150 AT SYSTEM 56
dvDVD		=	23015:1:0				//DENON DBT-3313UCI
vdvDVD		=	33015:1:0				//VDV FOR THE BLURAY PLAYER

//DXLINK, ICSLAN AND IP ATTACHED DEVICES
dvPROJ		=	22001:1:0				//DIGITAL PROJECTION EVISION 1080P
vdvPROJ		=	33016:1:0				//VDV FOR THE PROJ

dvTV1		=	22002:1:0				//SAMSUNG ME SERIES DISPLAY
vdvTV1		=	33017:1:0				//VDV FOR THAT TV

dvTV2		=	22003:1:0				//SAMSUNG ME SERIES DISPLAY
vdvTV2		=	33018:1:0				//VDV FOR THE SECOND TV

dvDOCCAM	=	23010:1:0				//WOLFVISION EYE-12
vdvDOCCAM	=	33019:1:0				//DOCCAM VDV

dvCAMERA1	=	0:3:0					//IP CONTROLED PANASONIC AW-HE60S
vdvCAMERA1	=	41020:1:0				//VDV FOR THAT CAMERA

dvCAMERA2	=	0:4:0					//IP CONTROLED PANASONIC AW-HE60S
vdvCAMERA2	=	41021:1:0				//VDV FOR THAT CAMERA

dvCAMERA3	=	0:5:0					//IP CONTROLED PANASONIC AW-HE60S
vdvCAMERA3	=	41022:1:0				//VDV FOR THAT CAMERA

//PLACE HOLDER VDVS FOR RMS SOURCE USEAGE
vdvSRC_LAPTOP	=	33030:1:0				//THESE ARE BLANK DEVICES USED FOR SOURCE USEAGE FB
vdvSRC_IPAD	=	33031:1:0
vdvSRC_PC	=	33032:1:0
vdvSRC_POD_DC	=	33033:1:0
vdvSRC_RACKVGA	=	33034:1:0
vdvSRC_RACKHDMI	=	33035:1:0
vdvSRC_PLATE1	=	33036:1:0
vdvSRC_PLATE2	=	33037:1:0
vdvSRC_PLATE3	=	33038:1:0

(***********************************************************)
(*               CONSTANT DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_CONSTANT

//ROUTING CONSTANTS
DVX_PROGRAM_BUS		=	1
DVX_PREVIEW_BUS		=	3
iDGX_DVX_SEND_1		=	5
iDGX_DVX_SEND_2		=	6

oPROJ			=	1
oTV1			=	2
oTV2			=	3
oMASTER_CONTROL 	=	4 //OBSELETE
oRACK_OUTPUT		=	5 //ALSO OBSELETE
oPREVIEW_ENC		=	6
oAUDIO			=	9
oLECTURE_CAP		=	8


iVPROC			=	14

oMC_MIXED_CAMS		=	4
oCAM_CAP		=	9
oCAM_PREVIEW		=	10

//TV ROUTING CONSTANTS
FOLLOW_PGM		=	1
FOLLOW_PREV		=	2

//TP STUFF
cROUTING_PAGES[][25]	=	{'ProjSingleWindow','ProjDualWindow','ProjTriWindow','ProjQuadWindow'}
(***********************************************************)
(*              DATA TYPE DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_TYPE

STRUCTURE _INPUT_DEFF						//STRUCTURE TO DESCRIBE ALL ATRIBUES OF AN INPUT
{
    INTEGER BTN							//TP CAHANEL CODE FOR THE SOURCE
    CHAR USR_NAME[50]						//USER FRIENDILY SOURCE NAME
    CHAR TP_PAGE[50]						//SYSTEM STANDARD CONTROL PAGE
    DEV DEVICE							//VDV THAT CONTROLS THE DEVICE
    INTEGER DVX_VIDEO_INPUT					//VIDEO INPUT ON THE SYSTEM LOCAL DVX
    INTEGER DVX_AUDIO_INPUT					//AUDIO INPUT ON THE SYSTEM LOCAL DVX
    INTEGER DGX_INPUT						//INPUT ON THE SYSTEM LOCAL DGX
    INTEGER MC_INPUT						//INPUT ON THE MASTER CONTROL DGX
    INTEGER IS_VALID_SOURCE					//IF THIS IS FALSE, THIS SOURCES IS NOT LISTED IN MASTER CONTROL, IF IT IS TRUE, THEN IT IS POSTED
    INTEGER CAN_PREVIEW						//IF THIS IS FALSE THE SOURCE WILL NOT PREVIEW
}
STRUCTURE _CAMERA_DEFF						//STRUCTURE TO DESCRIBE A CAMERA
{
    INTEGER LOCAL_INPUT						//LOCAL VIDEO SWITCH INPUT
    INTEGER MC_INPUT						//MASTER CONTROL CAM SWITCH INPUT
    INTEGER LOCAL_SWITCH_REQUIRED				//HIGH TO INDICATE THAT A LOCAL ROUTE HAS TO BE MADE INORDER FOR MC TO RECIEVE A CAMERA
    INTEGER IS_CONTROLABLE					//HIGH TO INDICATE THAT THE CAMERA CAN BE CONTROLED
    DEV DEVICE							//VDV OF THE CAMERA INCLUDING THE SYSTEM NUMBER
    CHAR USR_NAME[50]						//USER FRIENDILY NAME OF THE CAMERA
}
(***********************************************************)
(*               VARIABLE DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_VARIABLE
//DEVICE ARRAYS
VOLATILE DEV daTPS[] = {dvTP}					//DEV ARRAY FOR THE TOUCH PANELS

VOLATILE DEV daTVS[] ={vdvTV1,vdvTV2}				//DEV ARRAY FOR THE TVS

VOLATILE DEV daCAMERAS[] = {vdvCAMERA1,vdvCAMERA2,vdvCAMERA3}

VOLATILE DEV dvRMSTP[] = {dvRMS_TP}				//DEF ARRAYS FOR THE RMS TP INTERFACE
VOLATILE DEV dvRMSTP_Base[] = {dvTP}

//SYSTEM VARS	
VOLATILE INTEGER bDGX_READY					//TRACKS IF THE DVX AND DGX ARE ONLINE
VOLATILE INTEGER bDVX_READY

//VARS FOR THE ROUTING SIDE OF THINGS
VOLATILE INTEGER nINPUT_BUTTONS[] = {
					11,			//TP BUTTON 1 FOR THE PC PRIMARY DISPLAY
					12,			//TP BUTTON 2 FOR THE PC SECONDAY DISPLAY
					13,			//TP BUTTON 3 FOR THE LAPTOP
					14,			//TP BUTTON 4 FOE THE APPLE INTERFACE
					15,			//TP BUTTON 5 FOR THE PODIUM DOCCAM
					16,			//TP BUTTON 6 FOR THE CELIG DOCCAM
					17,			//TP BUTTON 7 FOR THE BLURAY PLAYER
					19,			//TP BUTTON 8 FOR THE LEFT INPUT
					20,			//TP BUTTON 9 FOR THE CENTER INPUT
					21,			//TP BUTTON 10 FOR THE RIGHT INPUT
					22,			//TP BUTTON 11 FOR THE RACK VGA INPUT
					23,			//TP BUTTON 12 FOR THE RACK HDMI INPUT
					24,			//TP BUTTON 13 FOR THE FUTURE APPLE TV
					25,			//TP EDUCAST PREVIEW
					26,			//TP CAMERA PREVIEW
					27,			//MASTER CONTROL INPUT 1
					28,			//MASTER CONTROL INPUT 2
					30}			//TP VTC BUTTON

VOLATILE _INPUT_DEFF uSYSTEM_INPUTS[20]				//STORES ALL RELEVANT INFO FOR ALL THE INPUTS, AND IS ALSO SENT TO MASTER CONTROL
VOLATILE _CAMERA_DEFF uCAMERAS[6]				//STORES ALL RELEVANT INFO FOR THE CAMERAS, AND IS ALSO SENT TO MASTER CONTROL
PERSISTENT INTEGER nCURRENT_INPUT					//STORES THE SELECTED INPUT ON THE TP
VOLATILE INTEGER nPROJ_INPUTS[4]				//STORES THE LAST TAKEN PROJECTOR SOURCES
PERSISTENT INTEGER nLAST_PC					//STORES THE LAST SELECTED PC DISPLAY
PERSISTENT INTEGER nLAST_ROOM_INPUT				//STORES THE LAST SELECTED ROOM INPUT
VOLATILE INTEGER bLAST_DVX_SEND	= {1}				//TRACKS THE LAST USED DVX SEND = EITHER 1 OR 2, AND SWITCHED BY THE TAKE BUTTONS
VOLATILE INTEGER nLAST_LAPTOP_OUT				//TRACKS THAT OUTPUT THE LAPTOP HAS BEEN ASSIGNED, BECAUSE OF THE AUTOSWITCH EVENT
VOLATILE INTEGER nPREV_POD_ROUTES[2]				//TRACKS PREVIOUS PODIUM ROUTES SO WE DONT OVERRITE
VOLATILE INTEGER nDVX_POD_SENDS[] = {DVX_PROGRAM_BUS,DVX_PREVIEW_BUS}//STORES THE DVX OUTPUTS FOR US
VOLATILE INTEGER nDGX_POD_INPUTS[] = {iDGX_DVX_SEND_1,iDGX_DVX_SEND_2}//STORES THE INPUTS ON THE DGX FOR THE PODIUM


//PROJECTOR LAYOUT VARS
PERSISTENT INTEGER nPROJ_DISPLAY_PRESET				//STORES THE LAYOUT PRESET FOR THE PROJ
VOLATILE INTEGER nPROJ_LAYOUT_BTNS[] = {35,36,37,38}		//PROJECTOR LAYOUT BUTTONS
VOLATILE INTEGER nPROJ_ROUTING_BTNS[] = {31,32,33,34}		//ROUTING TAKE BUTTONS FOR THE PROJ

//VARS FOR THE TVS
VOLATILE INTEGER nTV_SOURCE	= {2}					//STORES THE SOURCES FOR THE TVS
VOLATILE INTEGER nTV1_SRC_BTNS[] = {40,41,42,43,44,45,46}		//BUTTON CHANNELS FOR TV1'S SOURCE SELECTION

//CAMERAS
VOLATILE INTEGER nSELECTED_CAMERA = {1}
VOLATILE INTEGER nCAMERA_BTNS[] ={60,61,62}
VOLATILE INTEGER nCAMERA_CONTROL_BTNS[] = {70,71,72,73,74,75}
VOLATILE INTEGER nCAMERA_SNAPI_CHANNELS[]={132,133,134,135,158,159}
VOLATILE INTEGER nCAMERA_PRESET_BTNS[] = {76,77,78,79}
VOLATILE CHAR cERRORTEXT[250]					//FOR DEBUGING
VOLATILE LONG cERRORNUM	

//LECTURE CAPTURE BTNS
VOLATILE INTEGER nLECT_CAP_SRC_BTNS[] = {130,131,132,133}
PERSISTENT INTEGER nSELECTED_CAPTURE				//STORES THE SELECTED LECTURE CAPTURE SOURCE

//VARS FOR THE LIGHTING SYSTEM
VOLATILE CHAR cLIGNTING_PRESETS[][50] = {'1006 P1','1006 P2','1006 P3','1006 P4','1006 P5','1006 P6','1006 P7','1006 P8','1006 P9','1006 Off'}
VOLATILE INTEGER nLIGHTING_BTNS[] = {120,121,122,123,124,125,126,127,128,129}	//BUTTON CODES FOR THE LIGHTIGN BUTTONS
VOLATILE INTEGER nLIGHTING_CHANNELS[] = {1,2,3,4,5,6,7,8,9,10}			//VDV CHANNEL CODES FOR THE PRESETS
//STUFF FOR RMS
VOLATILE INTEGER nRMS_SOURCE_ACTIVE[20]				//USED TO ENSURE SOURCE USAGE IS ACCURATE


//AUDIO STUFF
VOLATILE CHAR cPGM_ID[] ={'lPGM'}
VOLATILE INTEGER nPGM_INST = {1}
VOLATILE CHAR cSP_ID[]	={'lMIC'}
VOLATILE INTEGER nSP_INST = {1}


//BLURAY STUFF
VOLATILE INTEGER nBD_TP_BTNS[] = {150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165}
VOLATILE INTEGER nBD_SNAPI_CH[]= {  1,  2,  3,  7,  6,  5,  4, 45, 46, 47, 48, 49,115, 44, 66,104}


DEFINE_CONNECT_LEVEL(vdvDSP_PGM,1,dvTP,1)			//CONNECT THE PROGRAM LEVEL FADER
DEFINE_CONNECT_LEVEL(vdvDSP_SP,1,dvTP,2)			//CONNECT THE SPEECH LEVEL

(***********************************************************)
(*               LATCHING DEFINITIONS GO BELOW             *)
(***********************************************************)
DEFINE_LATCHING

(***********************************************************)
(*       MUTUALLY EXCLUSIVE DEFINITIONS GO BELOW           *)
(***********************************************************)
DEFINE_MUTUALLY_EXCLUSIVE

(***********************************************************)
(*        SUBROUTINE/FUNCTION DEFINITIONS GO BELOW         *)
(***********************************************************)
#INCLUDE 'SNAPI'
#INCLUDE 'InputSetup1006'
#INCLUDE 'RmsSourceUsage'
(* EXAMPLE: DEFINE_FUNCTION <RETURN_TYPE> <NAME> (<PARAMETERS>) *)
(* EXAMPLE: DEFINE_CALL '<NAME>' (<PARAMETERS>) *)
DEFINE_FUNCTION fnUPDATE_RMS_SOURCE_USAGE(INTEGER nSOURCE, INTEGER nACTIVE)
{
    IF(nACTIVE == TRUE)								//IF THE SOURCE IS BEING MADE ACTIVE INCREMENT THE SOURCE USAGE COUNTER
    {
	nRMS_SOURCE_ACTIVE[nSOURCE]++
    }
    ELSE IF(nRMS_SOURCE_ACTIVE[nSOURCE]>0)					//IF THE SOURCE IS BEING MADE INACTIVE DECREMENT THE TRACKER BUT ONLY IF IT IS ABOVE ZERO
    {
	nRMS_SOURCE_ACTIVE[nSOURCE]--
    }
    
    IF(nRMS_SOURCE_ACTIVE[nSOURCE] = 1)				//IF THE SOURCE IS NOT ACTIVE, MAKE IT ACTIVE
    {
	RmsSourceUsageActivateSource(nSOURCE)
    }
    IF(nRMS_SOURCE_ACTIVE[nSOURCE] = FALSE && nACTIVE == FALSE)			//IF IT IS TIME TO KILL A SOURCE, DO IT
    {
	RmsSourceUsageDeactivateSource(nSOURCE)
    }
}
(***********************************************************)
(*                STARTUP CODE GOES BELOW                  *)
(***********************************************************)
DEFINE_START

//RMS SOURCE USAGE
RmsSourceUsageAssignAsset(1, uSYSTEM_INPUTS[1].DEVICE)
RmsSourceUsageAssignAsset(2, uSYSTEM_INPUTS[2].DEVICE)
RmsSourceUsageAssignAsset(3, uSYSTEM_INPUTS[3].DEVICE)
RmsSourceUsageAssignAsset(4, uSYSTEM_INPUTS[4].DEVICE)
RmsSourceUsageAssignAsset(5, uSYSTEM_INPUTS[5].DEVICE)
RmsSourceUsageAssignAsset(6, uSYSTEM_INPUTS[6].DEVICE)
RmsSourceUsageAssignAsset(7, uSYSTEM_INPUTS[7].DEVICE)
RmsSourceUsageAssignAsset(8, uSYSTEM_INPUTS[8].DEVICE)
RmsSourceUsageAssignAsset(9, uSYSTEM_INPUTS[9].DEVICE)
RmsSourceUsageAssignAsset(10, uSYSTEM_INPUTS[10].DEVICE)
RmsSourceUsageAssignAsset(12, uSYSTEM_INPUTS[11].DEVICE)
RmsSourceUsageAssignAsset(12, uSYSTEM_INPUTS[12].DEVICE)
RmsSourceUsageAssignAsset(13, uSYSTEM_INPUTS[13].DEVICE)
//RmsSourceUsageAssignAsset(14, uSYSTEM_INPUTS[14].DEVICE)	//ONLY DEVICES THAT ARE VALID SOURCES NEED TO BE DEFINED
//RmsSourceUsageAssignAsset(15, uSYSTEM_INPUTS[15].DEVICE)
//RmsSourceUsageAssignAsset(16, uSYSTEM_INPUTS[16].DEVICE)
//RmsSourceUsageAssignAsset(17, uSYSTEM_INPUTS[17].DEVICE)
//RmsSourceUsageAssignAsset(18, uSYSTEM_INPUTS[18].DEVICE)
//RmsSourceUsageAssignAsset(19, uSYSTEM_INPUTS[19].DEVICE)
//RmsSourceUsageAssignAsset(20, uSYSTEM_INPUTS[20].DEVICE)
RmsSourceUsageReset();

//THIS IS TO FIX A PROBLEM OF UN MUTEING ON INITIAL BOOT
ON[vdvDSP_PGM,VOL_MUTE_ON]						//MUTE THE MAINS
ON[vdvDSP_SP,VOL_MUTE_ON]						//MUTE THE SPEECH

//HERE COME THE MODULES
(***********************************************************)
(*                MODULE DEFINITIONS GO BELOW              *)
(***********************************************************)
//BASE RMS STUFF
DEFINE_MODULE 'RmsNetLinxAdapter_dr4_0_0' RMSNetLinxMod(vdvRMS);					//RMS CLIENT GATEWAY
DEFINE_MODULE 'RmsControlSystemMonitor' RmsControlSystemMonitorMod(vdvRMS,dvMaster);			//ENABLES MONITORING AND CONTROL OF THE MASTER

DEFINE_MODULE 'RmsTouchPanelMonitor' RMSTouchPanelMonitorMod(vdvRMS,dvTP)				//THE TOUCH PANEL MONITOR
DEFINE_MODULE 'RmsClientGui_dr4_0_0' RGUIMod(vdvRMS_GUI,dvRMSTP,dvRMSTP_Base);			//HANDELS ALL OF THE RMS HELP PAGES

DEFINE_MODULE 'RmsSystemPowerMonitor' RmsSystemPower(vdvRMS,dvMASTER)					//SYSTEM LEVEL POWER FB

//DEVICE MODS
DEFINE_MODULE 'BlackmagicVideoHub' CamSwitchMod(vdvCAM_SWITCH,dvCAM_SWITCH)	//DEVICE MODULE FOR THE BLACKMAGIC SMART VIDEO HUB **IP**
DEFINE_MODULE 'RmsNlSwitcherMonitor' CamSwitchMon(vdvRMS,vdvCAM_SWITCH,dvCAM_SWITCH)			//MONITOR FOR THE CAM SWITCH

DEFINE_MODULE 'Digital Projection Evision 1080p 8000' ProjDevMod(vdvPROJ,dvPROJ)			//DEVICE MODULE FOR THE PROJECTOR
//DEFINE_MODULE 'RmsNlVideoProjectorMonitor' NlProjDevMon(vdvRMS,vdvPROJ,dvPROJ)				//RMS PROJECTOR MONITOR

DEFINE_MODULE 'Samsung M Series Display' TV1DevMod(vdvTV1,dvTV1)
DEFINE_MODULE 'RmsNlTVMonitor' NlTV1DevMon(vdvRMS,vdvTV1,dvTV1)
DEFINE_MODULE 'Samsung M Series Display' TV2DevMod(vdvTV2,dvTV2)
DEFINE_MODULE 'RmsNlTVMonitor' NlTV2DevMon(vdvRMS,vdvTV2,dvTV2)

//DEFINE_MODULE 'RGB Spectrum QuadView HDx' VProcMod(vdvVPROC,dvVPROC)					//DEVICE MODUEL FOR THE QUAD PROC
//PUT RMS MONITOR HERE

DEFINE_MODULE 'Biamp Tesira Manager' NlDspDevMod(vdvDSP,dvDSP)					//BASE DSP MONITOR
DEFINE_MODULE 'Tesira Level Control' PgmLevelCtrl(vdvDSP_PGM,dvDSP,cPGM_ID,nPGM_INST)			//LEVEL CONTROL 1
DEFINE_MODULE 'RmsNlPgmAudioMonitor' PgmLevelMon(vdvRMS,vdvDSP_PGM,dvDSP)				//LEVEL MONITOR 1
DEFINE_MODULE 'Tesira Level Control' PgmLevelCtrl(vdvDSP_SP,dvDSP,cSP_ID,nSP_INST)			//LEVEL CONTROL 2
DEFINE_MODULE 'RmsNlVlAudioMonitor'  VlLevelMon(vdvRMS,vdvDSP_SP,dvDSP)					//LEVEL MONITOR 2

DEFINE_MODULE 'ETC Paradigm Lighting' NlLightingDevMod(vdvLIGHTING,dvLIGHTING,cLIGNTING_PRESETS)	//LINGING SYSTEM MOD
DEFINE_MODULE 'RmsNlLightSystemMonitor'NlRmsLightingMon(vdvRMS,vdvLIGHTING,dvLIGHTING)			//RIMS LIGHTING MONITOR

//CAMERAS - DISABLES TO SAVE SYSTEM RESOURCES
//DEFINE_MODULE 'Panasonic_AWHE50_IP_Comm_dr1_0_0' Cam1ComMod(vdvCAMERA1,dvCAMERA1)
//DEFINE_MODULE 'RmsDuetCameraMonitor' Cam1RMSMon(vdvRMS,vdvCAMERA1,dvCAMERA1)
//DEFINE_MODULE 'Panasonic_AWHE50_IP_Comm_dr1_0_0' Cam2ComMod(vdvCAMERA2,dvCAMERA2)
//DEFINE_MODULE 'RmsDuetCameraMonitor' Cam2RMSMon(vdvRMS,vdvCAMERA2,dvCAMERA2)
//DEFINE_MODULE 'Panasonic_AWHE50_IP_Comm_dr1_0_0' Cam3ComMod(vdvCAMERA3,dvCAMERA3)
//DEFINE_MODULE 'RmsDuetCameraMonitor' Cam3RMSMon(vdvRMS,vdvCAMERA3,dvCAMERA3)


//BLURAY
//DEFINE_MODULE 'Denon_DBP2012_Comm_dr1_0_0' DuetDvdDevMod(vdvDVD,dvDVD)					//DUET MOD FOR THE BLURAY PLAYER
DEFINE_MODULE 'Denon DBT-3313UDCI' BlurayMod(vdvDVD,dvDVD)

//DOCCAM
DEFINE_MODULE 'Wolfvision Eye-12' MAINDOCCAMMODULE(vdvDOCCAM,dvDOCCAM)					//NETLINX MODULE FOR THE DOCCAM
DEFINE_MODULE 'RmsNlDocCameraMonitor' MAINCAMERAMONITOR(vdvRMS,vdvDOCCAM,dvDOCCAM)			//MONITOR FOR THE DOCCAM

//VDV MONS FOR THE SOURCES
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE1MON (vdvRMS,uSYSTEM_INPUTS[1].DEVICE,uSYSTEM_INPUTS[1].USR_NAME,uSYSTEM_INPUTS[1].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE2MON (vdvRMS,uSYSTEM_INPUTS[2].DEVICE,uSYSTEM_INPUTS[2].USR_NAME,uSYSTEM_INPUTS[2].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE3MON (vdvRMS,uSYSTEM_INPUTS[3].DEVICE,uSYSTEM_INPUTS[3].USR_NAME,uSYSTEM_INPUTS[3].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE4MON (vdvRMS,uSYSTEM_INPUTS[4].DEVICE,uSYSTEM_INPUTS[4].USR_NAME,uSYSTEM_INPUTS[4].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE5MON (vdvRMS,uSYSTEM_INPUTS[5].DEVICE,uSYSTEM_INPUTS[5].USR_NAME,uSYSTEM_INPUTS[5].USR_NAME)

DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE7MON (vdvRMS,uSYSTEM_INPUTS[7].DEVICE,uSYSTEM_INPUTS[7].USR_NAME,uSYSTEM_INPUTS[7].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE7MON (vdvRMS,uSYSTEM_INPUTS[8].DEVICE,uSYSTEM_INPUTS[8].USR_NAME,uSYSTEM_INPUTS[8].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE9MON (vdvRMS,uSYSTEM_INPUTS[9].DEVICE,uSYSTEM_INPUTS[9].USR_NAME,uSYSTEM_INPUTS[9].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE10MON (vdvRMS,uSYSTEM_INPUTS[10].DEVICE,uSYSTEM_INPUTS[10].USR_NAME,uSYSTEM_INPUTS[10].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE11MON (vdvRMS,uSYSTEM_INPUTS[11].DEVICE,uSYSTEM_INPUTS[11].USR_NAME,uSYSTEM_INPUTS[11].USR_NAME)
DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE12MON (vdvRMS,uSYSTEM_INPUTS[12].DEVICE,uSYSTEM_INPUTS[12].USR_NAME,uSYSTEM_INPUTS[12].USR_NAME)
//DEFINE_MODULE 'RmsVirtualDeviceMonitor' SOURCE13MON (vdvRMS,uSYSTEM_INPUTS[13].DEVICE,uSYSTEM_INPUTS[13].USR_NAME,uSYSTEM_INPUTS[13].USR_NAME)

(***********************************************************)
(*                THE EVENTS GO BELOW                      *)
(***********************************************************)
DEFINE_EVENT
//SYSTEM INIT
DATA_EVENT[dvTP]
{
    ONLINE:
    {
	ON[daTPS,200]
	SEND_COMMAND daTPS,'PAGE-Boot'
	WAIT_UNTIL(bDGX_READY)
	{
	    ON[daTPS,201]
	}
	WAIT_UNTIL(bDVX_READY)
	{
	    ON[daTPS,202]
	}
	WAIT_UNTIL([vdvPROJ,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,203]
	}
	WAIT_UNTIL([vdvTV1,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,204]
	}
	WAIT_UNTIL([vdvTV2,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,205]
	}
	WAIT_UNTIL([vdvDSP,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,207]
	}
	WAIT_UNTIL([vdvCAM_SWITCH,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,209]
	}
	WAIT_UNTIL([vdvLIGHTING,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,211]
	}
	WAIT_UNTIL([vdvCAMERA1,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,212]
	}
	WAIT_UNTIL([vdvCAMERA2,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,213]
	}
	WAIT_UNTIL([vdvCAMERA3,DEVICE_COMMUNICATING])
	{
	    ON[daTPS,214]
	}
	WAIT_UNTIL([vdvRMS,RMS_CHANNEL_CLIENT_ONLINE] && [vdvRMS,RMS_CHANNEL_CLIENT_REGISTERED])
	{
	    ON[daTPS,208]
	    WAIT 100
	    {
		SEND_COMMAND daTPS,'ADBEEP'
		SEND_COMMAND daTPS,'PAGE-Splash'
		
		//INITIAL BUTTON FEEDBACK UPDATES GO HERE
		ON[daTPS,nTV1_SRC_BTNS[nTV_SOURCE]]
		ON[daTPS,nCAMERA_BTNS[nSELECTED_CAMERA]]
	    }
	}
    }
}

DATA_EVENT[dvDGX_SWITCHER]
{
    ONLINE:
    {
	bDGX_READY = TRUE
    }
    OFFLINE:
    {
	bDGX_READY = FALSE
    }
}

CHANNEL_EVENT[vdvDSP,DEVICE_COMMUNICATING]			//TRANSFER DEVICE_COMUNICATEING AND DATA_INITIALIZED TO THE INDIVIGUAL LEVEL CONTROLS FOR RMS
CHANNEL_EVENT[vdvDSP,DATA_INITIALIZED]
{
    ON:
    {
	ON[vdvDSP_PGM,CHANNEL.CHANNEL]
	ON[vdvDSP_SP,CHANNEL.CHANNEL]
    }
    OFF:
    {
	OFF[vdvDSP_PGM,CHANNEL.CHANNEL]			//WE JUST WANT TO HOPE THAT THIS NEVER GETS USED...
	OFF[vdvDSP_SP,CHANNEL.CHANNEL]
    }
}

//CAMERA INITS
DATA_EVENT[vdvCAMERA1]
{
    ONLINE:
    {
	SEND_COMMAND DATA.DEVICE,"'PROPERTY-IP_Address,172.27.52.226'"
	SEND_COMMAND DATA.DEVICE,"'REINIT'"
    }
}
DATA_EVENT[vdvCAMERA2]
{
    ONLINE:
    {
	SEND_COMMAND DATA.DEVICE,"'PROPERTY-IP_Address,172.27.52.227'"
	SEND_COMMAND DATA.DEVICE,"'REINIT'"
    }
}
DATA_EVENT[vdvCAMERA3]
{
    ONLINE:
    {
	SEND_COMMAND DATA.DEVICE,"'PROPERTY-IP_Address,172.27.52.228'"
	SEND_COMMAND DATA.DEVICE,"'REINIT'"
    }
}



//POWER CONTROL
BUTTON_EVENT[daTPS,1]								//SYSTEM ON
{
    PUSH:
    {
	SEND_COMMAND daTPS,'PAGE-Start'
	//SEND_STRING dvVPROC,"'sysrst',$0D"			//RESET THAT PIECE OF S%^T VIDEO WALL PROCESSOR
	PULSE[vdvPROJ,PWR_ON]
	SEND_COMMAND vdvRMS,"'SYSTEM.POWER.ON'"					//SET RMS SYSTEM POWER FB TO ON
	WAIT_UNTIL(![vdvPROJ,LAMP_WARMING_FB] && [vdvPROJ,POWER_FB])		//ONCE THE SYSTEM IS READY, PROCEDE
	{
	    WAIT 50 SEND_COMMAND daTPS,"'PAGE-Main'"
	    OFF[vdvDSP_PGM,VOL_MUTE_ON]						//UNMUTE THE MAINS
	    OFF[vdvDSP_SP,VOL_MUTE_ON]						//UNMUTE THE SPEECH
	    SEND_LEVEL vdvDSP_PGM,1,180						//SET THE VOLUME TO A DEFAULT VALUE
	    SEND_LEVEL vdvDSP_SP,1,180						//SET THE VOLUME TO A DEFAULT VALUE
	    PULSE[vdvTV1,PWR_ON]
	    PULSE[vdvTV2,PWR_ON]
	    PULSE[vdvDVD,PWR_ON]
	    PULSE[daCAMERAS,PWR_ON]
	}
    }
}

BUTTON_EVENT[daTPS,2]
{
    PUSH:
    {
	OFF[daCAMERAS,PWR_OFF]
	SEND_COMMAND daTPS,'PPOF-Exit Conf'
	WAIT 1 SEND_COMMAND daTPS,'PAGE-Cooldown'
	WAIT_UNTIL(![vdvPROJ,LAMP_WARMING_FB])
	{
	    PULSE[vdvPROJ,PWR_OFF]
	    PULSE[vdvTV1,PWR_OFF]
	    PULSE[vdvTV2,PWR_OFF]
	    
	    WAIT 50
	    {
		PULSE[vdvPROJ,PWR_OFF]
		PULSE[vdvTV1,PWR_OFF]
		PULSE[vdvTV2,PWR_OFF]
		PULSE[vdvDVD,PWR_OFF]
		PULSE[vdvDOCCAM,PWR_OFF]
		ON[vdvDSP_PGM,VOL_MUTE_ON]						//MUTE THE MAINS
		ON[vdvDSP_SP,VOL_MUTE_ON]						//MUTE THE SPEECH
		SEND_COMMAND vdvRMS,"'SYSTEM.POWER.OFF'"				//SET RMS SYSTEM POWER FB TO OFF
		WAIT_UNTIL(![vdvPROJ,LAMP_COOLING_FB] && ![vdvPROJ,LAMP_POWER_FB])
		{
		    SEND_COMMAND daTPS,'PAGE-Splash'
		}
	    }
	}
    }
}
BUTTON_EVENT[vdvRMS, RMS_CHANNEL_SYSTEM_POWER_ON]			//REMOTE POWER ON FROM RMS
{
    PUSH:
    {
	DO_PUSH(dvTP,1)
    }
}
BUTTON_EVENT[vdvRMS, RMS_CHANNEL_SYSTEM_POWER_OFF]			//REMOTE POWER OFF FROM RMS
{
    PUSH:
    {
	DO_PUSH(dvTP,2)
    }
}

CHANNEL_EVENT[vdvTV1,POWER_FB]
CHANNEL_EVENT[vdvTV2,POWER_FB]							//SWITCH THE DISPLAYS TO DVI WHEN THE COME ON
{
    ON:
    {
	WAIT 15 PULSE[CHANNEL.DEVICE,34]
    }
}
CHANNEL_EVENT[vdvPROJ,LAMP_WARMING_FB]
{
    OFF:
    {
	PULSE[CHANNEL.DEVICE,31]
    }
}

//SWITCHING STARTS HERE
BUTTON_EVENT[daTPS,nINPUT_BUTTONS]						//ALL OF THE VIDEO PREVIEW
{
    PUSH:
    {
	LOCAL_VAR INTEGER nLOOP							//LOOP COUNTER USED IN THE PROJ ROUTING FB LOOP
	if(uSYSTEM_INPUTS[GET_LAST(nINPUT_BUTTONS)].IS_VALID_SOURCE)		//ONLY UPDATE THE SOURCE LISTING IF THE SOURCE IS VALID
	{
	    fnUPDATE_RMS_SOURCE_USAGE(nCURRENT_INPUT,FALSE)				//PREVIOUS SOURCE WENT OFF OF PREVIEW
	    fnUPDATE_RMS_SOURCE_USAGE(GET_LAST(nINPUT_BUTTONS),TRUE)	//CURRENT SOURCE WENT ON PREVIEW
	}
	nCURRENT_INPUT = GET_LAST(nINPUT_BUTTONS)					//GET THE LAST BUTTON PUSHED
	
	//TP FEEDBACK
	OFF[daTPS,nINPUT_BUTTONS]						//ZERO THE INPUT BUTON FB
	OFF[daTPS,10]								//ZERO THE PC BUTTON FB
	OFF[daTPS,18]								//ZERO THE ROOM INPUT BUTTON
	ON[daTPS,nINPUT_BUTTONS[nCURRENT_INPUT]]				//SET FB ON SELECTED BUTTON
	IF(nCURRENT_INPUT == 1||nCURRENT_INPUT == 2)				//ONE OF THE PCS IS SELECTED
	{
	    ON[daTPS,10]							//SHOW THE PC SELECTION FB
	    nLAST_PC = nCURRENT_INPUT
	}
	ELSE IF(7 < nCURRENT_INPUT && nCURRENT_INPUT < 13)			//ONE OF THE ROOM INPUTS IS SELECTED
	{
	    ON[daTPS,18]							//SHOW THE ROOM INPUT SELECTION FB
	    nLAST_ROOM_INPUT = nCURRENT_INPUT
	}
	
	IF(nCURRENT_INPUT == 6)							//POWER ON THE DOCCAM ONCE SELECTED
	{
	    PULSE[vdvDOCCAM,PWR_ON]
	}
	IF(nCURRENT_INPUT == 7)							//POWER ON THE DVD ONCE SELECTED
	{
	    PULSE[vdvDVD,PWR_ON]
	}
	
	SEND_COMMAND daTPS,"'PPON-',uSYSTEM_INPUTS[nCURRENT_INPUT].TP_PAGE"	//SHOW THE APROPRIATE TP PAGE
	
	//PROJ ROUTING BUTTON FB UPDATE
	OFF[daTPS,nPROJ_ROUTING_BTNS]
	
	IF(nPROJ_INPUTS[1] == nCURRENT_INPUT)				//THIS USED TO BE IN A LOOP, BUT ISN'T NOW THAT THERE IS NO QUADVIEW PROC
	{
	    ON[daTPS,nPROJ_ROUTING_BTNS[nLOOP]]				//SET THE BUTTON HIGH IF THIS SOURCE IS ROUTED
	}
	
	
	
	//PREVIEW ROUTING STARTS HERE
	IF(uSYSTEM_INPUTS[nCURRENT_INPUT].CAN_PREVIEW)
	{
	    SEND_COMMAND dvDGX_SWITCHER,"'CLI',ITOA(uSYSTEM_INPUTS[nCURRENT_INPUT].DGX_INPUT),'O',ITOA(oTV1),'T',$0D"
	    SEND_COMMAND dvDGX_SWITCHER,"'CLI',ITOA(uSYSTEM_INPUTS[nCURRENT_INPUT].DGX_INPUT),'O',ITOA(oTV2),'T',$0D"
	}
    }
}
BUTTON_EVENT[daTPS,10]								//ON PC SELECTION RECALL THE LAST SELECTED PC
{
    PUSH:
    {
	DO_PUSH(dvTP,nINPUT_BUTTONS[nLAST_PC])
    }
}
BUTTON_EVENT[daTPS,18]								//ON PC SELECTION RECALL THE LAST SELECTED ROOM INPUT
{
    PUSH:
    {
	DO_PUSH(dvTP,nINPUT_BUTTONS[nLAST_ROOM_INPUT])
    }
}
//PROJECTOR ROUTING
BUTTON_EVENT[daTPS,nPROJ_ROUTING_BTNS]						//ROUTING TAKE BUTTONS FOR THE PROJECTOR
{
    PUSH:
    {
	STACK_VAR INTEGER nTEMP_INPUT							//STORES THE INPUT BECAUSE IT IS SOMETIME SWITCHED HERE
	STACK_VAR INTEGER nDVX_OUTPUT							//USED IN DETERMINEING THE OUTPUT OF THE DVX
	
	IF(uSYSTEM_INPUTS[nCURRENT_INPUT].IS_VALID_SOURCE)
	{
	    fnUPDATE_RMS_SOURCE_USAGE(nPROJ_INPUTS[GET_LAST(nPROJ_ROUTING_BTNS)],FALSE)	//PREVIOUS SOURCE GOES INCACTIVE
	    nPROJ_INPUTS[GET_LAST(nPROJ_ROUTING_BTNS)] = nCURRENT_INPUT			//UPDATE THE PROJ TRACKING VAR
	    fnUPDATE_RMS_SOURCE_USAGE(nPROJ_INPUTS[GET_LAST(nPROJ_ROUTING_BTNS)],TRUE)	//PREVIOUS SOURCE GOES ACTIVE
	}
	ON[BUTTON.INPUT]								//UPDATE THE ROUTING FB
	
	nTEMP_INPUT = uSYSTEM_INPUTS[nCURRENT_INPUT].DGX_INPUT				//LEFTOVER BAGGAGE FROM THAT WHOLE SEXTANT THING....
	
	SEND_COMMAND dvDGX_SWITCHER,"'CLI',ITOA(nTEMP_INPUT),'O',ITOA(oPROJ),'T',$0D"		//MAKE PROJ 1 ROUTE
	
	IF(nCURRENT_INPUT == 2)		//IF THE INPUT IS THE PC, MAKE THE AUDIO WORK
	{
	    SEND_COMMAND dvDGX_SWITCHER,"'CLI',ITOA(uSYSTEM_INPUTS[1].DGX_INPUT),'O',ITOA(oAUDIO),'T',$0D"
	}
	ELSE				//OTHERWISE, AUDIO FOLLOWS VIDEO
	{
	    SEND_COMMAND dvDGX_SWITCHER,"'CLI',ITOA(nTEMP_INPUT),'O',ITOA(oAUDIO),'T',$0D"
	}
	
	SEND_COMMAND dvDGX_SWITCHER,"'CLI',ITOA(nTEMP_INPUT),'O',ITOA(oLECTURE_CAP),'T',$0D"	//MAKE THE ROUTE TO 313LINK
    }
}

BUTTON_EVENT[daTPS,39]								//TV 1 POWER TOGGLE
{
    PUSH:
    {
	PULSE[vdvTV1,9]
    }
}
CHANNEL_EVENT[vdvTV1,POWER_FB]							//TV 1 POWER FB
{	
    ON:
    {
	ON[daTPS,39]
    }
    OFF:
    {
	OFF[daTPS,39]
    }
}
BUTTON_EVENT[daTPS,49]								//TV 2 POWER TOGGLE
{
    PUSH:
    {
	PULSE[vdvTV2,9]
    }
}
CHANNEL_EVENT[vdvTV2,POWER_FB]							//TV 2 POWER FB
{
    ON:
    {
	ON[daTPS,49]
    }
    OFF:
    {
	OFF[daTPS,49]
    }
}

//MANUAL PROJ CONTROLS
BUTTON_EVENT[daTPS,7]								//PROJ ON
{
    PUSH:
    {
	PULSE[vdvPROJ,PWR_ON]
	TO[BUTTON.INPUT]
    }
}
BUTTON_EVENT[daTPS,8]								//PROJ OFF
{
    PUSH:
    {
	PULSE[vdvPROJ,PWR_OFF]
	TO[BUTTON.INPUT]
    }
}
BUTTON_EVENT[daTPS,9]								//PROJ MUTE
{
    PUSH:
    {
	PULSE[vdvPROJ,PIC_MUTE]
    }
}
CHANNEL_EVENT[vdvPROJ,LAMP_POWER_FB]
{
    ON:
    {
	ON[daTPS,7]
	OFF[daTPS,8]
    }
    OFF:
    {
	OFF[daTPS,7]
	ON[daTPS,8]
    }
}
CHANNEL_EVENT[vdvPROJ,PIC_MUTE_FB]
{
    ON:
    {
	ON[daTPS,9]
    }
    OFF:
    {
	OFF[daTPS,9]
    }
}

//MAIN AUDIO CONTROL
BUTTON_EVENT[daTPS,100]								//MAIN VOLUME UP
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDSP_PGM,AUDIOPROC_LEVEL_UP]
    }
}
BUTTON_EVENT[daTPS,101]								//MAIN VOLUME DOWN
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDSP_PGM,AUDIOPROC_LEVEL_DN]
    }
}
BUTTON_EVENT[daTPS,102]
{
    PUSH:
    {
	TO[vdvDSP_PGM,VOL_MUTE]
    }
}
CHANNEL_EVENT[vdvDSP_PGM,VOL_MUTE_FB]
{
    ON:
    {
	ON[daTPS,102]
    }
    OFF:
    {
	OFF[daTPS,102]
    }
}
BUTTON_EVENT[daTPS,103]								//MAIN VOLUME UP
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDSP_SP,AUDIOPROC_LEVEL_UP]
    }
}
BUTTON_EVENT[daTPS,104]								//MAIN VOLUME DOWN
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDSP_SP,AUDIOPROC_LEVEL_DN]
    }
}
BUTTON_EVENT[daTPS,105]
{
    PUSH:
    {
	TO[vdvDSP_SP,VOL_MUTE]
    }
}
CHANNEL_EVENT[vdvDSP_SP,VOL_MUTE_FB]
{
    ON:
    {
	ON[daTPS,105]
    }
    OFF:
    {
	OFF[daTPS,105]
    }
}

//LIGHTING CONTROLS
BUTTON_EVENT[daTPS,nLIGHTING_BTNS]						//CONTROL FOR THE LIGHTING SYSTEM
{
    PUSH:
    {
	ON[vdvLIGHTING,GET_LAST(nLIGHTING_BTNS)]
    }
}
CHANNEL_EVENT[vdvLIGHTING,nLIGHTING_CHANNELS]					//FB FOR THE LIGHTING BUTTONS
{
    ON:
    {
	OFF[daTPS,nLIGHTING_BTNS]
	ON[daTPS,nLIGHTING_BTNS[GET_LAST(nLIGHTING_CHANNELS)]]
    }
}

//CAMERA ROUTING AND CONTROL STARTS HERE
BUTTON_EVENT[daTPS,nCAMERA_BTNS]						//ROUTING FOR THE CAMERAS
{
    PUSH:
    {
	nSELECTED_CAMERA = GET_LAST(nCAMERA_BTNS)				//STORE THE SELECTED CAMERA
	OFF[daTPS,nCAMERA_BTNS]
	ON[daTPS,nCAMERA_BTNS[nSELECTED_CAMERA]]				//UPDATE THE TP FEEDBACK
	
	SEND_COMMAND vdvCAM_SWITCH,"'CI',ITOA(uCAMERAS[nSELECTED_CAMERA].LOCAL_INPUT),'O',ITOA(oMC_MIXED_CAMS),'T',$0D"
	SEND_COMMAND vdvCAM_SWITCH,"'CI',ITOA(uCAMERAS[nSELECTED_CAMERA].LOCAL_INPUT),'O',ITOA(oCAM_CAP),'T',$0D"
	SEND_COMMAND vdvCAM_SWITCH,"'CI',ITOA(uCAMERAS[nSELECTED_CAMERA].LOCAL_INPUT),'O',ITOA(oCAM_PREVIEW),'T',$0D"
    }
}
BUTTON_EVENT[daTPS,nCAMERA_CONTROL_BTNS]
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[daCAMERAS[nSELECTED_CAMERA],nCAMERA_SNAPI_CHANNELS[GET_LAST(nCAMERA_CONTROL_BTNS)]]		//PASS THROUGH THE APROPRIATE SNAPI CAHNEL
    }
}
BUTTON_EVENT[daTPS,nCAMERA_PRESET_BTNS]
{
    PUSH:
    {
	WAIT 50 'PRESETSAVEFB'
	{
	    SEND_COMMAND daTPS,"'ADBEEP'"
	    PULSE[BUTTON.INPUT]
	}
    }
    RELEASE:
    {
	IF(BUTTON.HOLDTIME < 5000)
	{
	    CANCEL_WAIT 'PRESETSAVEFB'
	    SEND_COMMAND daCAMERAS[nSELECTED_CAMERA],"'CAMERAPRESET-',ITOA(GET_LAST(nCAMERA_PRESET_BTNS))"
	}
	ELSE
	{
	    SEND_COMMAND daCAMERAS[nSELECTED_CAMERA],"'CAMERAPRESETSAVE-',ITOA(GET_LAST(nCAMERA_PRESET_BTNS))"
	}
    }
}

//ALL THE DVD CONTROLS
BUTTON_EVENT[daTPS,nBD_TP_BTNS]
{
    push:
    {
	TO[BUTTON.INPUT]
	TO[vdvDVD,nBD_SNAPI_CH[GET_LAST(nBD_TP_BTNS)]]
    }
}
//DOCCAM CONTROLS
BUTTON_EVENT[daTPS,89]						//CONTROLS FOR THE DOCCAM, DOES WHAT THE SNAPI SAYS!
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDOCCAM,FOCUS_NEAR]
    }
}
BUTTON_EVENT[daTPS,90]
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDOCCAM,FOCUS_FAR]
    }
}
BUTTON_EVENT[daTPS,91]
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDOCCAM,AUTO_FOCUS]
    }
}
BUTTON_EVENT[daTPS,87]
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDOCCAM,ZOOM_IN]
    }
}
BUTTON_EVENT[daTPS,88]
{
    PUSH:
    {
	TO[BUTTON.INPUT]
	TO[vdvDOCCAM,ZOOM_OUT]
    }
}
(***********************************************************)
(*            THE ACTUAL PROGRAM GOES BELOW                *)
(***********************************************************)
DEFINE_PROGRAM

(***********************************************************)
(*                     END OF PROGRAM                      *)
(*        DO NOT PUT ANY CODE BELOW THIS COMMENT           *)
(***********************************************************)
